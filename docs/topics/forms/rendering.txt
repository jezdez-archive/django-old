Display forms as HTML
=====================

.. versionchanged:: 1.4

.. highlightlang:: html+django

Django provides helpers in the template language to make rendering a form in
HTML easy and reusable. In the example from :doc:`/topics/forms/index`, we
passed our ``ContactForm`` instance to the template using the context variable
``myform``. Here's a simple example template::

    <form action="/contact/" method="post">{% csrf_token %}
    {% form myform using "forms/layouts/p.html" %}
    <input type="submit" value="Submit" />
    </form>

The form only outputs its own fields; it is up to you to provide the surrounding
``<form>`` tags and the submit button.

.. admonition:: Forms and Cross Site Request Forgery protection

   Django ships with an easy-to-use :doc:`protection against Cross Site Request
   Forgeries </ref/contrib/csrf>`. When submitting a form via POST with
   CSRF protection enabled you must use the :ttag:`csrf_token` template tag
   as in the preceding example. However, since CSRF protection is not
   directly tied to forms in templates, this tag is omitted from the
   following examples in this document.

``{% form myform using "forms/layouts/p.html" %}`` will output the form with
each field and accompanying label wrapped in a paragraph. Here's the output
for our example template::

   <form action="/contact/" method="post">
   <p><label for="id_subject">Subject:</label>
       <input id="id_subject" type="text" name="subject" maxlength="100" /></p>
   <p><label for="id_message">Message:</label>
       <input type="text" name="message" id="id_message" /></p>
   <p><label for="id_sender">Sender:</label>
       <input type="text" name="sender" id="id_sender" /></p>
   <p><label for="id_cc_myself">Cc myself:</label>
       <input type="checkbox" name="cc_myself" id="id_cc_myself" /></p>
   <input type="submit" value="Submit" />
   </form>

You can also use ``forms/layouts/table.html`` to output table rows (you'll
need to provide your own ``<table>`` tags) and ``forms/layouts/ul.html`` to
output list items. See the :doc:`list of built-in form layouts
</ref/forms/layouts>` for more information.

.. note:: Enabling the forms template loader

   In order to make the default widget and form layout templates available, you
   must have ``'django.template.loaders.forms.Loader'`` in your
   :setting:`TEMPLATE_LOADERS` setting. To ease the transition for upgraded
   projects, Django will automatically add this loader to your
   :setting:`TEMPLATE_LOADERS` if it isn't there. This automatic assistance
   will result in a deprecation warning in Django 1.5, and will be removed in
   Django 1.6. Because form-rendering can involve loading the same templates
   many times over, for performance reasons it is strongly recommended to use
   the forms loader inside the :ref:`cached template
   loader<cached-template-loader>` .

Customizing the form template
-----------------------------

If the default generated HTML is not to your taste, you can completely
customize the way a form is presented using the Django template
language. Extending the above example::

    <form action="/contact/" method="post">
        {% form myform using "forms/layouts/my_layout.html" %}
        <p><input type="submit" value="Send message" /></p>
    </form>

``forms/layouts/my_layout.html`` is able to extend one of the built-in layouts,
modifying the parts you want to change::

    {% extends "forms/layouts/table.html" %}

    {% block errors %}
        <p>Following errors occurred that cannot be matched to a field:</p>
        {{ block.super }}
    {% endblock %}

See the :doc:`form layout reference </ref/forms/layouts>` for a detailed
description on how you can structure your custom layouts.

You can also specify your form layout "inline" rather than in a separate
template file, if you don't plan to reuse it. This is also done with the
:ttag:`form` tag::

    <form action="/signup/" method="post">
        {% form signupform using %}
        <div><label for="id_username">Username:</label>
           {% formfield form.username %}<div>
        <div><label for="id_password">Password:</label>
            {% formfield form.password %}</div>
        <div>
            <label for="id_firstname">First- and Lastname:</label><br />
            {% formfield form.firstname %}
            {% formfield form.lastname %}
        </div>
        {% endform %}
        <p><input type="submit" value="Send message" /></p>
    </form>

You can see that the ``signupform`` in the form tag will be available as
``form``. This is just for convenience, you could also use the original name.

Something new in the example is also the :ttag:`formfield` tag. It is used to
render the *widget* of a form field so that you don't have to type out all the
``<input />`` tags yourself.

But the example above is not all that you need to take into account when you
are creating your own design. You also need to take care where to display
errors if a field's validation fails, how to display the help text that might
be defined for a field, etc. Because of this it's in most cases easier to split
out these *form rows* (containing one or more fields) into their own
templates. They are just like form layouts explained earlier but for a subset
of fields. Here is how it might look like::

    <form action="/signup/" method="post">
        {% form signupform using %}
            {% formrow form.username using "div_row.html" %}
            {% formrow form.password using "div_row.html" %}
            {% formrow form.firstname form.lastname using "many_fields_div_row.html" with label="First- and Lastname" %}
        {% endform %}
        <p><input type="submit" value="Send message" /></p>
    </form>

See the :doc:`form layout reference </ref/forms/layouts>` for help in creating
your own form row templates.

Looping over the form's fields
------------------------------

If you're using the same HTML for each of your form fields, you can reduce
duplicate code by looping through each field in turn using a ``{% for %}``
loop::

    <form action="/contact/" method="post">
        {% for field in form %}
            <div class="fieldWrapper">
                <ul>
                {% for error in field.errors %}
                    <li>{{ error }}</li>
                {% endfor %}
                </ul>
                <label for="id_{{ field.html_name }}">{{ field.label }}</label>: {% formfield field %}
            </div>
        {% endfor %}
        <p><input type="submit" value="Send message" /></p>
    </form>

Within this loop, ``{{ field }}`` is an instance of :class:`BoundField`.
``BoundField`` also has the following attributes, which can be useful in your
templates:

    ``{{ field.label }}``
        The label of the field, e.g. ``Email address``.

    ``{{ field.html_name }}``
        The name of the field that will be used in the input element's name
        field. This takes the form prefix into account, if it has been set.

    ``{{ field.help_text }}``
        Any help text that has been associated with the field.

    ``{{ field.errors }}``
        A list of any validation errors corresponding to this field. You can
        customize the presentation of the errors with a ``{% for error in
        field.errors %}`` loop::

            <ol>
            {% for error in field.errors %}
                <li>{{ error }}</li>
            {% endfor %}
            </ol>

    ``field.is_hidden``
        This attribute is ``True`` if the form field is a hidden field and
        ``False`` otherwise. It's not particularly useful as a template
        variable, but could be useful in conditional tests such as::

            {% if field.is_hidden %}
               {# Do something special #}
            {% endif %}

Looping over hidden and visible fields
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

If you're manually laying out a form in a template, as opposed to relying on
Django's default form layout, you might want to treat ``<input type="hidden">``
fields differently than non-hidden fields. For example, because hidden fields
don't display anything, putting error messages "next to" the field could cause
confusion for your users -- so errors for those fields should be handled
differently.

Django provides two methods on a form that allow you to loop over the hidden
and visible fields independently: ``hidden_fields()`` and
``visible_fields()``. Here's a modification of an earlier example that uses
these two methods::

    <form action="/contact/" method="post">
        {% for field in form.visible_fields %}
            <div class="fieldWrapper">

                {# Include the hidden fields in the form #}
                {% if forloop.first %}
                    {% for hidden in form.hidden_fields %}
                    {% formfield hidden %}
                    {% endfor %}
                {% endif %}

                {% formrow field %}
            </div>
        {% endfor %}
        <p><input type="submit" value="Send message" /></p>
    </form>

This example does not handle any errors in the hidden fields. Usually, an
error in a hidden field is a sign of form tampering, since normal form
interaction won't alter them. However, you could easily insert some error
displays for those form errors, as well.
