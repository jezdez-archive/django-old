===========
Form wizard
===========

.. module:: django.contrib.formtools.wizard
    :synopsis: Splits forms across multiple Web pages.

Django comes with an optional "form wizard" application that splits
:doc:`forms </topics/forms/index>` across multiple Web pages. It maintains
state in one of the backends (by default signed cookie and session backend)
so that the full server-side processing can be delayed until the submission
of the final form.

You might want to use this if you have a lengthy form that would be too
unwieldy for display on a single page. The first page might ask the user for
core information, the second page might ask for less important information,
etc.

The term "wizard", in this context, is `explained on Wikipedia`_.

.. _explained on Wikipedia: http://en.wikipedia.org/wiki/Wizard_%28software%29
.. _forms: ../forms/


How it works
============

Here's the basic workflow for how a user would use a wizard:

    1. The user visits the first page of the wizard, fills in the form and
       submits it.
    2. The server validates the data. If it's invalid, the form is displayed
       again, with error messages. If it's valid, the server saves the current
       state of the wizard in the backend and redirects to the next step.
    3. Step 1 and 2 repeat, for every subsequent form in the wizard.
    4. Once the user has submitted all the forms and all the data has been
       validated, the wizard processes the data -- saving it to the database,
       sending an email, or whatever the application needs to do.


Usage
=====

This application handles as much machinery for you as possible. Generally, you
just have to do these things:

    1. Define a number of :class:`~django.forms.Form` classes -- one per wizard
       page.

    2. Create a :class:`WizardView` subclass that specifies what to do once all
       of your forms have been submitted and validated. This also lets you
       override some of the wizard's behavior.

    3. Create some templates that render the forms. You can define a single,
       generic template to handle every one of the forms, or you can define a
       specific template for each form.

    4. Add ``django.contrib.formtools.wizard`` to your :setting:`INSTALLED_APPS`
       list in your settings file.

    5. Point your URLconf at your :class:`WizardView` :meth:`as_view` method.


Defining ``Form`` classes
=========================

The first step in creating a form wizard is to create the
:class:`~django.forms.Form` classes.  These should be standard
:class:`django.forms.Form` classes, covered in the :doc:`forms documentation
</topics/forms/index>`.  These classes can live anywhere in your codebase, but
convention is to put them in a file called :file:`forms.py` in your
application.

For example, let's write a "contact form" wizard, where the first page's form
collects the sender's email address and subject, and the second page collects
the message itself. Here's what the :file:`forms.py` might look like::

    from django import forms

    class ContactForm1(forms.Form):
        subject = forms.CharField(max_length=100)
        sender = forms.EmailField()

    class ContactForm2(forms.Form):
        message = forms.CharField(widget=forms.Textarea)


.. note::

    In order to use :class:`~django.forms.FileField` in any form, see the
    section `Handling files with Form wizard`_ below to learn more about what
    to do.


Creating a ``WizardView`` class
===============================

The next step is to create a
:class:`django.contrib.formtools.wizard.view.WizardView` subclass. You can also
use the :class:`SessionWizardView` or :class:`CookieWizardView` class (which
preselects the wizard storage backend (session based or cookie based).

We will use the :class:`SessionWizardView` in all examples but is is completly
fine to use the :class:`CookieWizardView` instead.

As withyour :class:`~django.forms.Form` classes, this :class:`WizardView` class
can live anywhere in your codebase, but convention is to put it in
:file:`views.py`.

The only requirement on this subclass is that it implement a
:meth:`~WizardView.done()` method.

.. method:: WizardView.done

    This method specifies what should happen when the data for *every* form is
    submitted and validated. This method is passed one argument:

        * ``form_list`` -- a list of validated :class:`~django.forms.Form`
          instances

In this simplistic example, rather than perform any database operation, the
method simply renders a template of the validated data::

    from django.shortcuts import render_to_response
    from django.contrib.formtools.wizard.views import SessionWizardView

    class ContactWizard(SessionWizardView):
        def done(self, form_list, **kwargs):
            return render_to_response('done.html', {
                'form_data': [form.cleaned_data for form in form_list],
            })

Note that this method will be called via ``POST``, so it really ought to be a
good Web citizen and redirect after processing the data. Here's another
example::

    from django.http import HttpResponseRedirect
    from django.contrib.formtools.wizard.views import SessionWizardView

    class ContactWizard(SessionWizardView):
        def done(self, form_list, **kwargs):
            do_something_with_the_form_data(form_list)
            return HttpResponseRedirect('/page-to-redirect-to-when-done/')

See the section `Advanced WizardView methods`_ below to learn about more
:class:`WizardView` hooks.


Creating templates for the forms
================================

Next, you'll need to create a template that renders the wizard's forms. By
default, every form uses a template called
:file:`formtools/wizard/wizard_form.html`. (You can change this template name
by overriding either the :attr:`~WizardView.template_name` attribute or the
:meth:`~WizardView.get_template_names()` method, which is documented below.
This hook also allows you to use a different template for each form.)

This template expects a ``wizard`` object that has various items attached to
it:

    * ``form`` -- The :class:`~django.forms.Form` instance for the current
      step (either empty or with errors).
    * ``steps`` -- A helper object to access the various steps related data:

        * ``step0`` -- The current step (zero-based).
        * ``step1`` -- The current step (one-based).
        * ``count`` -- The total number of steps.
        * ``first`` -- The first step.
        * ``last`` -- The last step.
        * ``current`` -- The current (or first) step.
        * ``next`` -- The next step.
        * ``prev`` -- The previous step.
        * ``index`` -- The index of the current step.
        * ``all`` -- A list of all steps of the wizard.

You can supply extra context to this template in two ways:

    * Set the :attr:`~FormWizard.extra_context` attribute on your
      :class:`FormWizard` subclass to a dictionary.

    * Pass a dictionary as a parameter named ``extra_context`` to your wizard's
      URL pattern in your URLconf.  See `Hooking the wizard into a URLconf`_

Here's a full example template:

.. code-block:: html+django

    {% extends "base.html" %}

    {% block content %}
    <p>Step {{ wizard.steps.current }} of {{ wizard.steps.count }}</p>
    <form action="." method="post">{% csrf_token %}
    <table>
    {{ wizard.management_form }}
    {% if wizard.form.forms %}
        {{ wizard.form.management_form }}
        {% for form in wizard.form.forms %}
            {{ form }}
        {% endfor %}
    {% else %}
        {{ wizard.form }}
    {% endif %}
    {% if wizard.steps.prev %}
    <button name="wizard_prev_step" value="{{ wizard.steps.first }}">{% trans "first step" %}</button>
    <button name="wizard_prev_step" value="{{ wizard.steps.prev }}">{% trans "prev step" %}</button>
    {% endif %}
    </table>
    <input type="submit">
    </form>
    {% endblock %}

.. note::

    Note that ``management_form`` is required for the wizard to work properly.


Hooking the wizard into a URLconf
=================================

Finally, we need to specify which forms to use in the wizard, and then
deploy the new :class:`WizardView` object a URL in ``urls.py``. The
wizard :meth:`as_view` method takes a list of your :class:`~django.forms.Form`
classes as arguments when you instantiate the Wizard::

    from django.conf.urls.defaults import *
    from testapp.forms import ContactForm1, ContactForm2, ContactWizard

    urlpatterns = patterns('',
        (r'^contact/$', ContactWizard.as_view([ContactForm1, ContactForm2])),
    )


Advanced ``WizardView`` methods
===============================

.. class:: WizardView

    Aside from the :meth:`~done()` method, :class:`WizardView` offers a few
    advanced method hooks that let you customize how your wizard works.

    Some of these methods take an argument ``step``, which is a zero-based
    counter as string representing the current step of the wizard. (E.g., the
    first form is ``'0'`` and the second form is ``'1'``)

.. method:: WizardView.get_form_prefix

    Given the step, returns a form prefix to use. By default, this simply uses
    the step itself. For more, see the :ref:`form prefix documentation
    <form-prefix>`.

.. method:: WizardView.process_step

    Hook for modifying the wizard's internal state, given a fully validated
    :class:`~django.forms.Form` object. The Form is guaranteed to have clean,
    valid data.

    Note that this method is called every time a page is rendered for *all*
    submitted steps.

    The default implementation::

        def process_step(self, form):
            return self.get_form_step_data(form)


.. method:: WizardView.get_form_initial

    Returns a dictionary which will be passed to the form for ``step`` as
    ``initial``. If no initial data was provied while initializing the
    form wizard, a empty dictionary should be returned.

    The default implementation::

        def get_form_initial(self, step):
            return self.initial_dict.get(step, {})

.. method:: WizardView.get_form_instance

    Returns a object which will be passed to the form for ``step`` as
    ``instance``. If no instance object was provied while initializing
    the form wizard, None be returned.

    The default implementation::

        def get_form_instance(self, step):
            return self.instance_dict.get(step, None)

.. method:: WizardView.get_context_data

    Returns the template context for a step. You can overwrite this method
    to add more data for all or some steps. This method returns a dictionary
    containing the rendered form step.

    The default template context variables are:

        * `extra_data` -- current extra data dictionary
        * `form` -- form instance of the current step
        * `wizard` -- the wizard instance itself

    Example to add extra variables for a specific step:

    .. code-block:: python

        def get_context_data(self, form, **kwargs):
            context = super(MyWizard, self).get_context_data(form, **kwargs)
            if self.steps.current == 'my_step_name':
                context.update({'another_var': True})
            return context


Providing initial data for the forms
====================================

.. attribute:: WizardView.initial_dict

    Initial data for a wizard's :class:`~django.forms.Form` objects can be
    provided using the optional :attr:`~Wizard.initial_dict` keyword argument.
    This argument should be a dictionary mapping a step to a dictionary
    containing the initial data for that step. The dictionary of initial data
    will be passed along to the constructor of the step's
    :class:`~django.forms.Form`::

        >>> from testapp.forms import ContactForm1, ContactForm2, ContactWizard
        >>> initial = {
        ...     '0': {'subject': 'Hello', 'sender': 'user@example.com'},
        ...     '1': {'message': 'Hi there!'}
        ... }
        >>> wiz = ContactWizard.as_view([ContactForm1, ContactForm2], initial_dict=initial)
        >>> form1 = wiz.get_form('0')
        >>> form2 = wiz.get_form('1')
        >>> form1.initial
        {'sender': 'user@example.com', 'subject': 'Hello'}
        >>> form2.initial
        {'message': 'Hi there!'}


Handling files with Form wizard
===============================

To handle :class:`~django.forms.FileField` within any step form of the wizard,
you have to add a :attr:`file_storage` to your :class:`WizardView` subclass.

This storage will temporary store the uploaded files for the wizard. The
:attr:`file_storage` attribute should be a
:class:`~django.core.files.storage.Storage` subclass.

.. note::

    Please remember to take care of removing old files as the WizardView won't
    remove any files, wether the wizard gets finished corretly or not.

    The best way is to remove files of this storage, that are older than a
    specific time.

Conditionally view/skip specific steps
======================================

TBD.

How to work with ModelForm and ModelFormSet
===========================================

TBD.

Usage of NamedUrlWizardView
===========================

TBD.
