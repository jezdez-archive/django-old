===========
Form wizard
===========

.. module:: django.contrib.formtools.wizard
    :synopsis: Splits forms across multiple Web pages.

Django comes with an optional "form wizard" application that splits
:doc:`forms </topics/forms/index>` across multiple Web pages. It maintains
state in one of the backends (by default signed cookie and session backend)
so that the full server-side processing can be delayed until the submission
of the final form.

You might want to use this if you have a lengthy form that would be too
unwieldy for display on a single page. The first page might ask the user for
core information, the second page might ask for less important information,
etc.

The term "wizard", in this context, is `explained on Wikipedia`_.

.. _explained on Wikipedia: http://en.wikipedia.org/wiki/Wizard_%28software%29
.. _forms: ../forms/


How it works
============

Here's the basic workflow for how a user would use a wizard:

    1. The user visits the first page of the wizard, fills in the form and
       submits it.
    2. The server validates the data. If it's invalid, the form is displayed
       again, with error messages. If it's valid, the server saves the current
       state of the wizard in the backend and redirects to the next step.
    3. Step 1 and 2 repeat, for every subsequent form in the wizard.
    4. Once the user has submitted all the forms and all the data has been
       validated, the wizard processes the data -- saving it to the database,
       sending an email, or whatever the application needs to do.


Usage
=====

This application handles as much machinery for you as possible. Generally, you
just have to do these things:

    1. Define a number of :class:`~django.forms.Form` classes -- one per wizard
       page.

    2. Create a :class:`WizardView` subclass that specifies what to do once all
       of your forms have been submitted and validated. This also lets you
       override some of the wizard's behavior.

    3. Create some templates that render the forms. You can define a single,
       generic template to handle every one of the forms, or you can define a
       specific template for each form.

    4. Add ``django.contrib.formtools.wizard`` to your :setting:`INSTALLED_APPS`
       list in your settings file.

    5. Point your URLconf at your :class:`WizardView` :meth:`as_view` method.


Defining ``Form`` classes
=========================

The first step in creating a form wizard is to create the
:class:`~django.forms.Form` classes.  These should be standard
:class:`django.forms.Form` classes, covered in the :doc:`forms documentation
</topics/forms/index>`.  These classes can live anywhere in your codebase, but
convention is to put them in a file called :file:`forms.py` in your
application.

For example, let's write a "contact form" wizard, where the first page's form
collects the sender's email address and subject, and the second page collects
the message itself. Here's what the :file:`forms.py` might look like::

    from django import forms

    class ContactForm1(forms.Form):
        subject = forms.CharField(max_length=100)
        sender = forms.EmailField()

    class ContactForm2(forms.Form):
        message = forms.CharField(widget=forms.Textarea)


.. note::

    In order to use :class:`~django.forms.FileField` in any form, see the
    section `Handling files with Form wizard`_ below to learn more about what
    to do.


Creating a ``WizardView`` class
===============================

The next step is to create a
:class:`django.contrib.formtools.wizard.view.WizardView` subclass. You can also
use the :class:`SessionWizardView` or :class:`CookieWizardView` class (which
preselects the wizard storage backend (session based or cookie based).

We will use the :class:`SessionWizardView` in all examples but is is completly
fine to use the :class:`CookieWizardView` instead.

As withyour :class:`~django.forms.Form` classes, this :class:`WizardView` class
can live anywhere in your codebase, but convention is to put it in
:file:`views.py`.

The only requirement on this subclass is that it implement a
:meth:`~WizardView.done()` method.

.. method:: WizardView.done

    This method specifies what should happen when the data for *every* form is
    submitted and validated. This method is passed one argument:

        * ``form_list`` -- a list of validated :class:`~django.forms.Form`
          instances

In this simplistic example, rather than perform any database operation, the
method simply renders a template of the validated data::

    from django.shortcuts import render_to_response
    from django.contrib.formtools.wizard.views import SessionWizardView

    class ContactWizard(SessionWizardView):
        def done(self, form_list, **kwargs):
            return render_to_response('done.html', {
                'form_data': [form.cleaned_data for form in form_list],
            })

Note that this method will be called via ``POST``, so it really ought to be a
good Web citizen and redirect after processing the data. Here's another
example::

    from django.http import HttpResponseRedirect
    from django.contrib.formtools.wizard.views import SessionWizardView

    class ContactWizard(SessionWizardView):
        def done(self, form_list, **kwargs):
            do_something_with_the_form_data(form_list)
            return HttpResponseRedirect('/page-to-redirect-to-when-done/')

See the section `Advanced WizardView methods`_ below to learn about more
:class:`WizardView` hooks.


Creating templates for the forms
================================

Next, you'll need to create a template that renders the wizard's forms. By
default, every form uses a template called
:file:`formtools/wizard/wizard_form.html`. (You can change this template name
by overriding either the :attr:`~WizardView.template_name` attribute or the
:meth:`~WizardView.get_template_names()` method, which is documented below.
This hook also allows you to use a different template for each form.)

This template expects a ``wizard`` object that has various items attached to
it:

    * ``form`` -- The :class:`~django.forms.Form` instance for the current
      step (either empty or with errors).
    * ``steps`` -- A helper object to access the various steps related data:

        * ``step0`` -- The current step (zero-based).
        * ``step1`` -- The current step (one-based).
        * ``count`` -- The total number of steps.
        * ``first`` -- The first step.
        * ``last`` -- The last step.
        * ``current`` -- The current (or first) step.
        * ``next`` -- The next step.
        * ``prev`` -- The previous step.
        * ``index`` -- The index of the current step.
        * ``all`` -- A list of all steps of the wizard.

You can supply extra context to this template in two ways:

    * Set the :attr:`~FormWizard.extra_context` attribute on your
      :class:`FormWizard` subclass to a dictionary.

    * Pass a dictionary as a parameter named ``extra_context`` to your wizard's
      URL pattern in your URLconf.  See `Hooking the wizard into a URLconf`_

Here's a full example template:

.. code-block:: html+django

    {% extends "base.html" %}

    {% block content %}
    <p>Step {{ wizard.steps.current }} of {{ wizard.steps.count }}</p>
    <form action="." method="post">{% csrf_token %}
    <table>
    {{ wizard.management_form }}
    {% if wizard.form.forms %}
        {{ wizard.form.management_form }}
        {% for form in wizard.form.forms %}
            {{ form }}
        {% endfor %}
    {% else %}
        {{ wizard.form }}
    {% endif %}
    {% if wizard.steps.prev %}
    <button name="wizard_prev_step" value="{{ wizard.steps.first }}">{% trans "first step" %}</button>
    <button name="wizard_prev_step" value="{{ wizard.steps.prev }}">{% trans "prev step" %}</button>
    {% endif %}
    </table>
    <input type="submit">
    </form>
    {% endblock %}

.. note::

    Note that ``management_form`` is required for the wizard to work properly.


Hooking the wizard into a URLconf
=================================

Finally, we need to specify which forms to use in the wizard, and then
deploy the new :class:`WizardView` object a URL in ``urls.py``. The
wizard :meth:`as_view` method takes a list of your :class:`~django.forms.Form`
classes as arguments when you instantiate the Wizard::

    from django.conf.urls.defaults import *
    from testapp.forms import ContactForm1, ContactForm2, ContactWizard

    urlpatterns = patterns('',
        (r'^contact/$', ContactWizard.as_view([ContactForm1, ContactForm2])),
    )


Advanced ``WizardView`` methods
===============================

.. class:: WizardView

    Aside from the :meth:`~done()` method, :class:`WizardView` offers a few
    advanced method hooks that let you customize how your wizard works.

    Some of these methods take an argument ``step``, which is a zero-based
    counter as string representing the current step of the wizard. (E.g., the
    first form is ``'0'`` and the second form is ``'1'``)

.. method:: WizardView.get_form_prefix

    Given the step, returns a form prefix to use. By default, this simply uses
    the step itself. For more, see the :ref:`form prefix documentation
    <form-prefix>`.

.. method:: WizardView.process_step

    Hook for modifying the wizard's internal state, given a fully validated
    :class:`~django.forms.Form` object. The Form is guaranteed to have clean,
    valid data.

    Note that this method is called every time a page is rendered for *all*
    submitted steps.

    The default implementation::

        def process_step(self, form):
            return self.get_form_step_data(form)


.. method:: WizardView.get_form_initial

    Returns a dictionary which will be passed to the form for ``step`` as
    ``initial``. If no initial data was provied while initializing the
    form wizard, a empty dictionary should be returned.

    The default implementation::

        def get_form_initial(self, step):
            return self.initial_dict.get(step, {})

.. method:: WizardView.get_form_instance

    Returns a object which will be passed to the form for ``step`` as
    ``instance``. If no instance object was provied while initializing
    the form wizard, None be returned.

    The default implementation::

        def get_form_instance(self, step):
            return self.instance_dict.get(step, None)

.. method:: WizardView.get_context_data

    Returns the template context for a step. You can overwrite this method
    to add more data for all or some steps. This method returns a dictionary
    containing the rendered form step.

    The default template context variables are:

        * `extra_data` -- current extra data dictionary
        * `form` -- form instance of the current step
        * `wizard` -- the wizard instance itself

    Example to add extra variables for a specific step::

        def get_context_data(self, form, \*\*kwargs):
            context = super(MyWizard, self).get_context_data(form, \*\*kwargs)
            if self.steps.current == 'my_step_name':
                context.update({'another_var': True})
            return context

.. method:: WizardView.wizard_name

    This method is decorated by @property to act like an attribute. You can
    change this method to change the wizard's internal name.

    Default implementation::

        def wizard_name(self):
            return normalize_name(self.__class__.__name__)

.. method:: WizardView.prefix

    This method returns a prefix for the storage backends. These backends use
    the prefix to fetch the correct data for the wizard. (Multiple wizards
    could save their data in one session)

    You can change this method to make the wizard data prefix more unique to,
    e.g. have multiple instances of one wizard in one session.

    Default implementation:

        def prefix(self):
            return self.wizard_name

.. method:: WizardView.get_form

    This method constructs the form for a given `step`. If no `step` is defined,
    the current step will be determined automatically. The method gets three
    arguments::

    * ``step`` -- The step for which the form instance should be generated.
    * ``data`` -- Gets passed to the form's data argument
    * ``files`` -- Gets passed to the form's files argument

    You can override this method to add extra arguments to the form instance.

    Example code to add a user attribute to the form on step 2::

        def get_form(self, step=None, data=None, files=None):
            form = super(MyWizard, self).get_form(step, data, files)

            if step == '1':
                form.user = self.request.user

            return form

.. method:: WizardView.process_step

    This method gives you a way to post-process the form data before the data
    gets stored within the storage backend. By default it just passed the
    form.data dictionary. You should not manipulate the data here but you can
    use the data to do some extra work if needed (e.g. set extra_data).

    Default implementation::

        def process_step(self, form):
            return self.get_form_step_data(form)

.. method:: WizardView.process_step_files

    This method gives you a way to post-process the form files before the files
    gets stored within the storage backend. By default it just passed the
    form.files dictionary. You should not manipulate the data here but you can
    use the data to do some extra work if needed (e.g. set extra_data).

    Default implementation::

        def process_step_files(self, form):
            return self.get_form_step_files(form)

.. method:: WizardView.render_revalidation_failure

    When the wizard thinks, all steps passed it revalidates all forms with the
    data from the backend storage.

    If any of the forms doesn't validate correctly, this method gets called.
    This method expects two arguments, ``step`` and ``form``.

    The default implementation reset the current step to the first failing form
    and redirects the user to the invalid form.

    Default implementation::

        def render_revalidation_failure(self, step, form, **kwargs):
            self.storage.current_step = step
            return self.render(form, **kwargs)

.. method:: WizardView.get_form_step_data

    This method fetches the form data from and returns the dictionary. You can
    use this method to manipulate the values before the data gets stored in
    the storage backend.

    Default implementation::

        def get_form_step_data(self, form):
            return form.data

.. method:: WizardView.get_form_step_files

    This method fetches the form files from and returns the dictionary. You can
    use this method to manipulate the files before the data gets stored in
    the storage backend.

    Default implementation::

        def get_form_step_files(self, form):
            return form.files

.. method:: WizardView.get_extra_data

    This method returns the content of the stored extra data. You can override
    this method to change the extra_data which gets passed to the template and
    can be used by other methods. The default implementation passes the
    extra_data dictionary from the storage backend.

    Default implementation::

        def get_extra_data(self):
            return self.storage.extra_data

.. method:: WizardView.update_extra_data

    This method expects one argument ``data``. The method will fetch the current
    extra_data content and update the dictionary with the passed data and store
    the content back to storage backend.

    E.g. you could change this method to protect the extra_data dictionary from
    external changes by just doing nothing.

    Example code::

        def update_extra_data(self, data):
            pass

.. method:: WizardView.render

    This method gets called after the get or post request was handled. You can
    hook in this method to, e.g. change the type of http response.

    Default implementation::

        def render(self, form=None, **kwargs):
            form = form or self.get_form()
            context = self.get_context_data(form, **kwargs)
            return self.render_to_response(context)


Providing initial data for the forms
====================================

.. attribute:: WizardView.initial_dict

    Initial data for a wizard's :class:`~django.forms.Form` objects can be
    provided using the optional :attr:`~Wizard.initial_dict` keyword argument.
    This argument should be a dictionary mapping a step to a dictionary
    containing the initial data for that step. The dictionary of initial data
    will be passed along to the constructor of the step's
    :class:`~django.forms.Form`::

        >>> from testapp.forms import ContactForm1, ContactForm2, ContactWizard
        >>> initial = {
        ...     '0': {'subject': 'Hello', 'sender': 'user@example.com'},
        ...     '1': {'message': 'Hi there!'}
        ... }
        >>> wiz = ContactWizard.as_view([ContactForm1, ContactForm2], initial_dict=initial)
        >>> form1 = wiz.get_form('0')
        >>> form2 = wiz.get_form('1')
        >>> form1.initial
        {'sender': 'user@example.com', 'subject': 'Hello'}
        >>> form2.initial
        {'message': 'Hi there!'}


Handling files with Form wizard
===============================

To handle :class:`~django.forms.FileField` within any step form of the wizard,
you have to add a :attr:`file_storage` to your :class:`WizardView` subclass.

This storage will temporary store the uploaded files for the wizard. The
:attr:`file_storage` attribute should be a
:class:`~django.core.files.storage.Storage` subclass.

.. note::

    Please remember to take care of removing old files as the WizardView won't
    remove any files, wether the wizard gets finished corretly or not.

    The best way is to remove files of this storage, that are older than a
    specific time.

Conditionally view/skip specific steps
======================================

.. attribute:: WizardView.condition_dict

TBD.

How to work with ModelForm and ModelFormSet
===========================================

TBD.

Usage of NamedUrlWizardView
===========================

TBD.
